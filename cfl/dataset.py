"""
Dataset Module
"""

import numpy as np

# Boolean, unsigned integer, signed integer, float, complex.
_NUMERIC_KINDS = set('buifc')

class Dataset():
    """
    The Dataset class packages X and Y so that they can be easily 
    passed through steps of CFL and saved consistently. It enforces separation
    of any withheld datasets passed through CFL for prediction after training.

    Note:
        Xraw and Yraw attributes will be deprecated soon as the visualizations
        interface has changed and no longer requires them to be stored in a
        Dataset.
    """

    def __init__(self, X, Y, name='dataset', Xraw=None, Yraw=None,
                 in_sample_idx=None, out_sample_idx=None):
        ''' Initialize Dataset.

            Arguments:
                X (np.ndarray) : X data to pass through CFL pipeline, dimensions 
                    (n_samples, n_x_features). #TODO: dimensions different if 
                    going to use a CNN 
                Y (np.ndarray) : Y data to pass through CFL pipeline, dimensions 
                    (n_samples, n_y_features). 
                name (str) : name of Dataset. Defaults to 'dataset'. 
                Xraw (np.ndarray) : (Optional) raw form of X before 
                    preprocessing to remain
                    associated with X for visualization. Defaults to None.
                Yraw (np.ndarray) : (Optional) raw form of Y before 
                    preprocessing to remain
                    associated with Y for visualization. Defaults to None. 

            Returns: 
                None
        '''

        # check data input types
        assert isinstance(X, np.ndarray), \
            'X should be of type np.ndarray. Actual type: {}'.format(type(X))
        assert isinstance(Y, np.ndarray), \
            'Y should be of type np.ndarray. Actual type: {}'.format(type(Y))
        assert isinstance(Xraw, (np.ndarray, type(None))), \
            'Xraw should be of type np.ndarray or NoneType. ' + \
            'Actual type: {}'.format(type(Xraw))
        assert isinstance(Yraw, (np.ndarray, type(None))), \
            'Yraw should be of type np.ndarray or NoneType. ' + \
            'Actual type: {}'.format(type(Yraw))
        assert isinstance(name, str), 'name should be of type str. ' + \
            'Actual type: {}'.format(type(name))
        assert isinstance(in_sample_idx, (np.ndarray, type(None))), \
            'in_sample_idx should be of type np.ndarray or None. Actual type: \
            {}'.format(type(in_sample_idx))
        assert isinstance(out_sample_idx, (np.ndarray, type(None))), \
            'in_sample_idx should be of type np.ndarray or None. Actual type: \
            {}'.format(type(out_sample_idx))
        for data, data_name in zip([X, Y, Xraw, Yraw], ['X', 'Y', 'Xraw', 'Yraw']):
            if data is not None:
                try:
                    assert np.sum(
                        np.isnan(data)) == 0, 'np.nan entries not accepted'
                except:
                    raise TypeError(f'The entries in {data_name} should be of a ' +
                                    f'numeric data type. Got type {data.dtype} ' +
                                    'instead')

        self.X = X
        self.Y = Y
        self.n_samples = X.shape[0]

        if Xraw is None:
            self.Xraw = self.X
        else:
            self.Xraw = Xraw
        if Yraw is None:
            self.Yraw = self.Y
        else:
            self.Yraw = Yraw

        self.in_sample_idx = in_sample_idx
        self.out_sample_idx = out_sample_idx

        self.name = name
        self.cfl_results = None

    def get_name(self):
        ''' Return the name of this Dataset.
            Arguments: None
            Returns:
                str : name associated with this Dataset.
        '''
        return self.name

    def get_X(self):
        ''' 
        Return X array associated with this Dataset
        Arguments: None
        Returns:
            np.ndarray : an (n_samples,n_X_features) array
        '''
        return self.X

    def get_Y(self):
        ''' 
        Return Y array associated with this Dataset
        Arguments: None
        Returns:
            np.ndarray : an (n_samples,n_Y_features) array
        '''        
        return self.Y

    def get_cfl_results(self):
        ''' 
        Return cfl results generated by passing this dataset through 
        Experiment training or prediction.
        Arguments: None
        Returns:
            dict : results generated by cfl.Experiment.train or .predict
        '''
        return self.cfl_results

    def set_cfl_results(self, cfl_results):
        ''' 
        Assign results from a CFL Experiment run to this Dataset.
        Arguments: 
            cfl_results (dict) : results generated by cfl.Experiment.train 
                or .predict
        Returns: None
        '''
        self.cfl_results = cfl_results

    def get_in_sample_idx(self):
        ''' 
        Return in_sample_idx set for this Dataset.
        Arguments: None
        Returns:
            np.ndarray : an array of sample indices in this subset
        '''
        return self.in_sample_idx

    def get_out_sample_idx(self):
        ''' 
        Return out_sample_idx set for this Dataset.
        Arguments: None
        Returns:
            np.ndarray : an array of sample indices in this subset
        '''        
        return self.out_sample_idx

    def set_in_sample_idx(self, in_sample_idx):
        ''' 
        Set in_sample_idx set for this Dataset.
        Arguments:
            in_sample_idx (np.ndarray) : an array of sample indices in this 
                subset
        Returns: None
        '''
        self.in_sample_idx = in_sample_idx

    def set_out_sample_idx(self, out_sample_idx):
        ''' 
        Set out_sample_idx set for this Dataset.
        Arguments:
            out_sample_idx (np.ndarray) : an array of sample indices in this 
                subset
        Returns: None
        '''
        self.out_sample_idx = out_sample_idx
